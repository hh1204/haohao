import re

# Python里数量词默认是贪婪的（在少数语言里也可能是默认非贪婪），总是尝试匹配尽可能多的字符；
# 非贪婪则相反，总是尝试匹配尽可能少的字符。
# 在"*","?","+","{m,n}"后面加上？，使贪婪变成非贪婪。
s="This is a number 234-235-22-423"
r=re.match(".+(\d+-\d+-\d+-\d+)",s)
print(r.group(1))
r=re.match(".+?(\d+-\d+-\d+-\d+)",s)
print(r.group(1))
# 正则表达式模式中使用到通配字，那它在从左到右的顺序求值时，会尽量“抓取”满足匹配最长字符串，在我们上面的例子里面，“.+”会从字符串的启始处抓取满足模式的最长字符，其中包括我们想得到的第一个整型字段的中的大部分，“\d+”只需一位字符就可以匹配，所以它匹配了数字“4”，而“.+”则匹配了从字符串起始到这个第一位数字4之前的所有字符。

# 解决方式：非贪婪操作符“？”，这个操作符可以用在"*","+","?"的后面，要求正则匹配的越少越好。

print(re.match(r"aa(\d+)","aa2343ddd").group(1))
print(re.match(r"aa(\d+?)","aa2343ddd").group(1))
print(re.match(r"aa(\d+)ddd","aa2343ddd").group(1))
print(re.match(r"aa(\d+?)ddd","aa2343ddd").group(1))

# Python中字符串前面加上 r 表示原生字符串，
# 与大多数编程语言相同，正则表达式里使用"\"作为转义字符，这就可能造成反斜杠困扰。假如你需要匹配文本中的字符"\"，那么使用编程语言表示的正则表达式里将需要4个反斜杠"\\"：前两个和后两个分别用于在编程语言里转义成反斜杠，转换成两个反斜杠后再在正则表达式里转义成一个反斜杠。
# Python里的原生字符串很好地解决了这个问题，有了原生字符串，你再也不用担心是不是漏写了反斜杠，写出来的表达式也更直观。
mm = "c:\\a\\b\\c"
ret = re.match(r"c:\\a",mm).group()
print(ret)